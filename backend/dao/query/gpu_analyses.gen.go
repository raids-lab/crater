// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/raids-lab/crater/dao/model"
)

func newGpuAnalysis(db *gorm.DB, opts ...gen.DOOption) gpuAnalysis {
	_gpuAnalysis := gpuAnalysis{}

	_gpuAnalysis.gpuAnalysisDo.UseDB(db, opts...)
	_gpuAnalysis.gpuAnalysisDo.UseModel(&model.GpuAnalysis{})

	tableName := _gpuAnalysis.gpuAnalysisDo.TableName()
	_gpuAnalysis.ALL = field.NewAsterisk(tableName)
	_gpuAnalysis.ID = field.NewUint(tableName, "id")
	_gpuAnalysis.CreatedAt = field.NewTime(tableName, "created_at")
	_gpuAnalysis.DeletedAt = field.NewField(tableName, "deleted_at")
	_gpuAnalysis.JobID = field.NewUint(tableName, "job_id")
	_gpuAnalysis.JobName = field.NewString(tableName, "job_name")
	_gpuAnalysis.UserID = field.NewUint(tableName, "user_id")
	_gpuAnalysis.UserName = field.NewString(tableName, "user_name")
	_gpuAnalysis.PodName = field.NewString(tableName, "pod_name")
	_gpuAnalysis.Namespace = field.NewString(tableName, "namespace")
	_gpuAnalysis.Phase1Score = field.NewInt(tableName, "phase1_score")
	_gpuAnalysis.Phase2Score = field.NewInt(tableName, "phase2_score")
	_gpuAnalysis.Phase1LLMReason = field.NewString(tableName, "phase1_llm_reason")
	_gpuAnalysis.Phase2LLMReason = field.NewString(tableName, "phase2_llm_reason")
	_gpuAnalysis.LLMVersion = field.NewString(tableName, "llm_version")
	_gpuAnalysis.Command = field.NewString(tableName, "command")
	_gpuAnalysis.ScriptContent = field.NewString(tableName, "script_content")
	_gpuAnalysis.HistoricalMetrics = field.NewString(tableName, "historical_metrics")
	_gpuAnalysis.ReviewStatus = field.NewUint8(tableName, "review_status")

	_gpuAnalysis.fillFieldMap()

	return _gpuAnalysis
}

type gpuAnalysis struct {
	gpuAnalysisDo gpuAnalysisDo

	ALL               field.Asterisk
	ID                field.Uint
	CreatedAt         field.Time
	DeletedAt         field.Field  // 软删除时间戳
	JobID             field.Uint   // 关联的作业ID，用于跳转，但不设外键约束
	JobName           field.String // 关联的作业名称 (冗余字段，用于显示)
	UserID            field.Uint   // 关联的用户ID，用于统计
	UserName          field.String // 提交作业的用户名 (冗余字段，用于显示)
	PodName           field.String // 被分析的Pod名称
	Namespace         field.String // Pod所在的命名空间
	Phase1Score       field.Int    // 基于监控数据的初步评分
	Phase2Score       field.Int    // 结合脚本内容的二次评分
	Phase1LLMReason   field.String // LLM给出的初步分析理由
	Phase2LLMReason   field.String // LLM给出的二次分析理由
	LLMVersion        field.String // 使用的LLM模型版本
	Command           field.String // GPU进程的启动命令
	ScriptContent     field.String // 获取到的脚本内容
	HistoricalMetrics field.String // 用于分析的历史指标摘要(JSON格式)
	ReviewStatus      field.Uint8  // 审核状态 (1: Pending, 2: Confirmed, 3: Ignored)

	fieldMap map[string]field.Expr
}

func (g gpuAnalysis) Table(newTableName string) *gpuAnalysis {
	g.gpuAnalysisDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gpuAnalysis) As(alias string) *gpuAnalysis {
	g.gpuAnalysisDo.DO = *(g.gpuAnalysisDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gpuAnalysis) updateTableName(table string) *gpuAnalysis {
	g.ALL = field.NewAsterisk(table)
	g.ID = field.NewUint(table, "id")
	g.CreatedAt = field.NewTime(table, "created_at")
	g.DeletedAt = field.NewField(table, "deleted_at")
	g.JobID = field.NewUint(table, "job_id")
	g.JobName = field.NewString(table, "job_name")
	g.UserID = field.NewUint(table, "user_id")
	g.UserName = field.NewString(table, "user_name")
	g.PodName = field.NewString(table, "pod_name")
	g.Namespace = field.NewString(table, "namespace")
	g.Phase1Score = field.NewInt(table, "phase1_score")
	g.Phase2Score = field.NewInt(table, "phase2_score")
	g.Phase1LLMReason = field.NewString(table, "phase1_llm_reason")
	g.Phase2LLMReason = field.NewString(table, "phase2_llm_reason")
	g.LLMVersion = field.NewString(table, "llm_version")
	g.Command = field.NewString(table, "command")
	g.ScriptContent = field.NewString(table, "script_content")
	g.HistoricalMetrics = field.NewString(table, "historical_metrics")
	g.ReviewStatus = field.NewUint8(table, "review_status")

	g.fillFieldMap()

	return g
}

func (g *gpuAnalysis) WithContext(ctx context.Context) IGpuAnalysisDo {
	return g.gpuAnalysisDo.WithContext(ctx)
}

func (g gpuAnalysis) TableName() string { return g.gpuAnalysisDo.TableName() }

func (g gpuAnalysis) Alias() string { return g.gpuAnalysisDo.Alias() }

func (g gpuAnalysis) Columns(cols ...field.Expr) gen.Columns { return g.gpuAnalysisDo.Columns(cols...) }

func (g *gpuAnalysis) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gpuAnalysis) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 18)
	g.fieldMap["id"] = g.ID
	g.fieldMap["created_at"] = g.CreatedAt
	g.fieldMap["deleted_at"] = g.DeletedAt
	g.fieldMap["job_id"] = g.JobID
	g.fieldMap["job_name"] = g.JobName
	g.fieldMap["user_id"] = g.UserID
	g.fieldMap["user_name"] = g.UserName
	g.fieldMap["pod_name"] = g.PodName
	g.fieldMap["namespace"] = g.Namespace
	g.fieldMap["phase1_score"] = g.Phase1Score
	g.fieldMap["phase2_score"] = g.Phase2Score
	g.fieldMap["phase1_llm_reason"] = g.Phase1LLMReason
	g.fieldMap["phase2_llm_reason"] = g.Phase2LLMReason
	g.fieldMap["llm_version"] = g.LLMVersion
	g.fieldMap["command"] = g.Command
	g.fieldMap["script_content"] = g.ScriptContent
	g.fieldMap["historical_metrics"] = g.HistoricalMetrics
	g.fieldMap["review_status"] = g.ReviewStatus
}

func (g gpuAnalysis) clone(db *gorm.DB) gpuAnalysis {
	g.gpuAnalysisDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g gpuAnalysis) replaceDB(db *gorm.DB) gpuAnalysis {
	g.gpuAnalysisDo.ReplaceDB(db)
	return g
}

type gpuAnalysisDo struct{ gen.DO }

type IGpuAnalysisDo interface {
	gen.SubQuery
	Debug() IGpuAnalysisDo
	WithContext(ctx context.Context) IGpuAnalysisDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGpuAnalysisDo
	WriteDB() IGpuAnalysisDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGpuAnalysisDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGpuAnalysisDo
	Not(conds ...gen.Condition) IGpuAnalysisDo
	Or(conds ...gen.Condition) IGpuAnalysisDo
	Select(conds ...field.Expr) IGpuAnalysisDo
	Where(conds ...gen.Condition) IGpuAnalysisDo
	Order(conds ...field.Expr) IGpuAnalysisDo
	Distinct(cols ...field.Expr) IGpuAnalysisDo
	Omit(cols ...field.Expr) IGpuAnalysisDo
	Join(table schema.Tabler, on ...field.Expr) IGpuAnalysisDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGpuAnalysisDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGpuAnalysisDo
	Group(cols ...field.Expr) IGpuAnalysisDo
	Having(conds ...gen.Condition) IGpuAnalysisDo
	Limit(limit int) IGpuAnalysisDo
	Offset(offset int) IGpuAnalysisDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGpuAnalysisDo
	Unscoped() IGpuAnalysisDo
	Create(values ...*model.GpuAnalysis) error
	CreateInBatches(values []*model.GpuAnalysis, batchSize int) error
	Save(values ...*model.GpuAnalysis) error
	First() (*model.GpuAnalysis, error)
	Take() (*model.GpuAnalysis, error)
	Last() (*model.GpuAnalysis, error)
	Find() ([]*model.GpuAnalysis, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GpuAnalysis, err error)
	FindInBatches(result *[]*model.GpuAnalysis, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.GpuAnalysis) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGpuAnalysisDo
	Assign(attrs ...field.AssignExpr) IGpuAnalysisDo
	Joins(fields ...field.RelationField) IGpuAnalysisDo
	Preload(fields ...field.RelationField) IGpuAnalysisDo
	FirstOrInit() (*model.GpuAnalysis, error)
	FirstOrCreate() (*model.GpuAnalysis, error)
	FindByPage(offset int, limit int) (result []*model.GpuAnalysis, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGpuAnalysisDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g gpuAnalysisDo) Debug() IGpuAnalysisDo {
	return g.withDO(g.DO.Debug())
}

func (g gpuAnalysisDo) WithContext(ctx context.Context) IGpuAnalysisDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gpuAnalysisDo) ReadDB() IGpuAnalysisDo {
	return g.Clauses(dbresolver.Read)
}

func (g gpuAnalysisDo) WriteDB() IGpuAnalysisDo {
	return g.Clauses(dbresolver.Write)
}

func (g gpuAnalysisDo) Session(config *gorm.Session) IGpuAnalysisDo {
	return g.withDO(g.DO.Session(config))
}

func (g gpuAnalysisDo) Clauses(conds ...clause.Expression) IGpuAnalysisDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gpuAnalysisDo) Returning(value interface{}, columns ...string) IGpuAnalysisDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gpuAnalysisDo) Not(conds ...gen.Condition) IGpuAnalysisDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gpuAnalysisDo) Or(conds ...gen.Condition) IGpuAnalysisDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gpuAnalysisDo) Select(conds ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gpuAnalysisDo) Where(conds ...gen.Condition) IGpuAnalysisDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gpuAnalysisDo) Order(conds ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gpuAnalysisDo) Distinct(cols ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gpuAnalysisDo) Omit(cols ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gpuAnalysisDo) Join(table schema.Tabler, on ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gpuAnalysisDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gpuAnalysisDo) RightJoin(table schema.Tabler, on ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gpuAnalysisDo) Group(cols ...field.Expr) IGpuAnalysisDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gpuAnalysisDo) Having(conds ...gen.Condition) IGpuAnalysisDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gpuAnalysisDo) Limit(limit int) IGpuAnalysisDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gpuAnalysisDo) Offset(offset int) IGpuAnalysisDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gpuAnalysisDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGpuAnalysisDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gpuAnalysisDo) Unscoped() IGpuAnalysisDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gpuAnalysisDo) Create(values ...*model.GpuAnalysis) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gpuAnalysisDo) CreateInBatches(values []*model.GpuAnalysis, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gpuAnalysisDo) Save(values ...*model.GpuAnalysis) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gpuAnalysisDo) First() (*model.GpuAnalysis, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.GpuAnalysis), nil
	}
}

func (g gpuAnalysisDo) Take() (*model.GpuAnalysis, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.GpuAnalysis), nil
	}
}

func (g gpuAnalysisDo) Last() (*model.GpuAnalysis, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.GpuAnalysis), nil
	}
}

func (g gpuAnalysisDo) Find() ([]*model.GpuAnalysis, error) {
	result, err := g.DO.Find()
	return result.([]*model.GpuAnalysis), err
}

func (g gpuAnalysisDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.GpuAnalysis, err error) {
	buf := make([]*model.GpuAnalysis, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gpuAnalysisDo) FindInBatches(result *[]*model.GpuAnalysis, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gpuAnalysisDo) Attrs(attrs ...field.AssignExpr) IGpuAnalysisDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gpuAnalysisDo) Assign(attrs ...field.AssignExpr) IGpuAnalysisDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gpuAnalysisDo) Joins(fields ...field.RelationField) IGpuAnalysisDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gpuAnalysisDo) Preload(fields ...field.RelationField) IGpuAnalysisDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gpuAnalysisDo) FirstOrInit() (*model.GpuAnalysis, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.GpuAnalysis), nil
	}
}

func (g gpuAnalysisDo) FirstOrCreate() (*model.GpuAnalysis, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.GpuAnalysis), nil
	}
}

func (g gpuAnalysisDo) FindByPage(offset int, limit int) (result []*model.GpuAnalysis, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gpuAnalysisDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g gpuAnalysisDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g gpuAnalysisDo) Delete(models ...*model.GpuAnalysis) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *gpuAnalysisDo) withDO(do gen.Dao) *gpuAnalysisDo {
	g.DO = *do.(*gen.DO)
	return g
}
