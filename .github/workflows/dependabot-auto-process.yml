# Copyright 2025 Crater
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Dependabot Auto Label and Merge Workflow
# 
# This workflow automatically processes Dependabot PRs for submodule updates:
# 1. Adds appropriate labels based on submodule type (backend/frontend/storage server)
# 2. Enables auto-merge for the PR (GitHub will merge when all checks pass)
#
# Triggered when: Dependabot creates a new PR
# Permissions: pull-requests: write, issues: write

name: Dependabot Auto Label and Merge

on:
  pull_request:
    types: [opened]

jobs:
  dependabot-auto-process:
    if: github.event.pull_request.user.login == 'dependabot[bot]'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      contents: write
    steps:
      - name: Get Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v1.6.0
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"
          
      - name: Add labels based on submodule type
        uses: actions/github-script@v7
        with:
          script: |
            const title = context.payload.pull_request.title;
            const labels = context.payload.pull_request.labels.map(label => label.name);
            
            // 根据PR标题添加特定标签（backend/frontend/storage server）
            if (title.includes('crater-backend')) {
              if (!labels.includes('backend')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: ['backend']
                });
                console.log('Added backend label to PR #' + context.payload.pull_request.number);
              }
            }
            
            if (title.includes('crater-frontend')) {
              if (!labels.includes('frontend')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: ['frontend']
                });
                console.log('Added frontend label to PR #' + context.payload.pull_request.number);
              }
            }
            
            if (title.includes('storage-server')) {
              if (!labels.includes('storage server')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: ['storage server']
                });
                console.log('Added storage server label to PR #' + context.payload.pull_request.number);
              }
            }
            
      - name: Enable auto-merge for submodule updates
        run: |
          # Enhanced retry mechanism with randomization to handle concurrent PR issues
          # See: https://github.com/raids-lab/crater/issues/126
          
          # Random initial delay (0-60 seconds) to spread out concurrent workflows
          INITIAL_DELAY=$((RANDOM % 61))
          sleep $INITIAL_DELAY
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          # Random base delay between 8-12 seconds
          BASE_DELAY=$((8 + RANDOM % 5))
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if gh pr merge --auto --squash "$PR_URL"; then
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                # Exponential backoff with random base delay: base_delay * 2^retry_count
                RETRY_DELAY=$((BASE_DELAY * (2 ** RETRY_COUNT)))
                sleep $RETRY_DELAY
              else
                exit 1
              fi
            fi
          done
        env:
          PR_URL: ${{github.event.pull_request.html_url}}
          GH_TOKEN: ${{secrets.GITHUB_TOKEN}}
